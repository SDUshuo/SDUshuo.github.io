

本节课程主要分为四个方面：

1. 自动内存管理

1. Go 内存管理及优化

1. 编译器和静态分析

1. Go 编译器优化

## Go内存分配

目标：为对象在heap上分配内存

提前将内存分块

### 缓存

每个p包含一个mcache用于快速分配，用于为绑定于p上的g分配对象
mcache管理一组mspan
当mcache 中的mspan分配完毕，向mcentral申请带有未分配块的mspan
当mspan中没有分配的对象，mspan会被缓存在mcentral 中，而不是立刻释放并归还给OS

![image-20230129111801633](C:/Users/len/AppData/Roaming/Typora/typora-user-images/image-20230129111801633.png)

### Balanced GC优化方案

每个g都绑定一大块内存(1 KB)，称作goroutine allocation buffer (GAB)

GAB用于noscan类型的小对象分配: <128 B

使用三个指针维护GAB: base, end, top

Bump pointer(指针碰撞）风格对象分配

![image-20230129112044255](C:/Users/len/AppData/Roaming/Typora/typora-user-images/image-20230129112044255.png)

本质：将多个小对象的分配合并成一次大对象的分配  

## 编译器和静态分析

### 编译器结构

**重要的系统软件**
	·识别符合语法和非法的程序。生成正确且高效的代码分析部分

**前端（front end)**

​	词法分析，生成词素(lexeme)

​	语法分析，生成语法树
​	语义分析，收集类型信息，进行语义检查
​	中间代码生成，生成intermediate representation (IR)

**综合部分(后端back end)**
	·代码优化，机器无关优化，生成优化后的IR·代码生成，生成目标代码

### 静态分析

不运行代码，分析代码程序的行为，分析其性质，优化代码

### 过程内分析和过程间分析

过程内分析(lntra-procedural analysis)：仅在函数内部进行分析
过程间分析(Inter-procedural analysis)：考虑函数调用时参数传递和返回值的数据流和控制流

## Go编译器优化

### 函数内联

内联:将被调用函数的函数体(callee)的副本替换到调用位置(caller)上，同时重写代码以反映参数的绑定

### 逃逸分析

分析代码中指针的动态作用域，若指针p在当前作用域S传递出去，则逃逸成功





# 课后

1. 从业务层和语言运行时层进行优化分别有什么特点？

1. 从软件工程的角度出发，为了保证语言 SDK 的可维护性和可拓展性，在进行运行时优化时需要注意什么？

1. 自动内存管理技术从大类上分为哪两种，每一种技术的特点以及优缺点有哪些？

1. 什么是分代假说？分代 GC 的初衷是为了解决什么样的问题？

1. Go 是如何管理和组织内存的？

1. 为什么采用 bump-pointer 的方式分配内存会很快？

1. 为什么我们需要在编译器优化中进行静态代码分析？

1. 函数内联是什么，这项优化的优缺点是什么？

1. 什么是逃逸分析？逃逸分析是如何提升代码性能的？



作者：青训营官方账号
链接：https://juejin.cn/post/7189525739836801085/
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
